## Веб-приложение для проведения интерактивных квизов в реальном времени — **QuizFlow**

---

## 1. Назначение и функциональность приложения

**QuizFlow** — веб-платформа для создания и проведения викторин (квизов) в режиме реального времени. Приложение поддерживает две роли пользователей:

- **Организатор** — создаёт квизы, управляет вопросами, запускает сессии и следит за ходом игры из панели ведущего.
- **Участник** — подключается к сессии по 6-символьному коду комнаты, отвечает на вопросы и видит результаты в таблице лидеров.

**Ключевые возможности:**

| Функция | Описание |
|---|---|
| Регистрация и авторизация | Cookie-сессии, хэширование паролей (bcrypt), ролевая модель |
| Создание квизов | Текстовые и графические вопросы, одиночный и множественный выбор, таймер и баллы |
| Проведение сессий | Lobby → Question → Reveal → Finished, синхронизация состояния через WebSocket |
| Реальное время | Мгновенные обновления таймера, приём ответов, раскрытие правильных вариантов |
| Результаты и аналитика | Таблица лидеров, точность ответов участника, статистика сессии |

---

## 2. Обоснование выбора средств разработки

### 2.1 Next.js 14 (App Router) + React + TypeScript

Next.js выбран как основной фреймворк по следующим причинам:

- **Fullstack в одном репозитории** — API Routes и серверные компоненты устраняют необходимость отдельного Express-сервера для REST-части, снижая операционную сложность.
- **App Router + Server Components** — страницы вроде Dashboard и Results рендерятся на сервере, что даёт быструю первую загрузку без клиентских waterfall-запросов.
- **TypeScript** обеспечивает статическую типизацию на всём стеке: от Prisma-моделей до компонентов интерфейса, что снижает класс ошибок на этапе разработки.

### 2.2 Socket.IO

Для реального времени использован Socket.IO вместо нативного WebSocket API:

- Встроенный **fallback на long-polling** при ограниченной сетевой среде.
- **Комнаты (rooms)** — каждая игровая сессия изолирована в отдельной комнате, что исключает утечку событий между сессиями.
- **Двунаправленный протокол событий** позволяет точно моделировать конечный автомат сессии: `session:join → session:start → question:show → answer:submit → answer:reveal → leaderboard:update`.

Socket.IO-сервер запущен как отдельный Node.js-процесс на порту 3001, независимо от Next.js, что позволяет масштабировать их раздельно.

### 2.3 PostgreSQL + Prisma ORM

- **PostgreSQL** выбран за поддержку массивов (`String[]` для `selectedOptionIds`), надёжные транзакции и зрелую экосистему.
- **Prisma** предоставляет типобезопасный клиент, автоматически генерируемый из схемы (`schema.prisma`). Это позволяет использовать полные типы Prisma в TypeScript-коде без ручного дублирования интерфейсов (`ReturnType<typeof getQuizzesByOwner>`).
- Миграции через `prisma migrate dev` обеспечивают версионирование схемы в git.

### 2.4 Tailwind CSS

- **Utility-first подход** позволяет реализовать дизайн-систему с единым набором токенов (цвета, радиусы, тени) через `tailwind.config.ts` без написания отдельных CSS-файлов.
- Конфигурируемые токены (`--primary`, `--app-bg`, `shadow-soft`, `rounded-q-md` и др.) обеспечивают визуальную консистентность всего приложения.

### 2.5 Zod

Zod используется для валидации входящих данных на API-маршрутах. Схемы (`CreateQuizInput`, `CreateQuestionInput`) определены единожды и применяются и на фронтенде, и на бэкенде — принцип единого источника истины для контрактов данных.

---

## 3. Архитектура приложения

```
┌─────────────────────────────────────────────────────┐
│                   Браузер (Client)                  │
│  React компоненты · useSocket · useSession hooks    │
└──────────────┬──────────────────────┬───────────────┘
               │ HTTP (REST)          │ WebSocket
               ▼                     ▼
┌──────────────────────┐   ┌─────────────────────────┐
│  Next.js (port 3000) │   │ Socket.IO (port 3001)   │
│  App Router          │   │  handlers.ts            │
│  API Routes          │   │  sessionManager.ts      │
└──────────┬───────────┘   └───────────┬─────────────┘
           │                           │
           └──────────┬────────────────┘
                      ▼
           ┌──────────────────────┐
           │  PostgreSQL (Prisma) │
           │  Users · Quizzes     │
           │  Sessions · Scores   │
           └──────────────────────┘
```

**Модель данных** включает 7 сущностей: `User`, `Quiz`, `Question`, `Option`, `Session`, `SessionParticipant`, `Answer`, `Score`. Каскадные удаления (`onDelete: Cascade`) обеспечивают целостность при удалении родительских записей.

**Конечный автомат сессии:**

```
LOBBY → QUESTION → REVEAL → QUESTION → ... → FINISHED
```

Состояние хранится в PostgreSQL (`Session.status`) и синхронизируется через Socket.IO-события при каждом переходе.

---

## 4. Основные этапы разработки

### Этап 1 — Проектирование схемы данных
Определена реляционная схема в `prisma/schema.prisma`: роли пользователей (`ORGANIZER`, `PARTICIPANT`), модели квиза и вопросов, сессионная модель с конечным автоматом статусов, модели ответов и счёта. Написан seed-скрипт с тестовыми аккаунтами.

### Этап 2 — Аутентификация и ролевая модель
Реализованы `POST /api/auth/register` и `POST /api/auth/login` с хэшированием паролей через `bcryptjs`. Сессии хранятся в HTTP-only cookies. Функция `getCurrentUser()` используется во всех серверных компонентах для защиты маршрутов.

### Этап 3 — REST API для управления квизами
Разработаны CRUD-маршруты для квизов и вопросов (`/api/quizzes`, `/api/questions`). Входные данные валидируются Zod-схемами. Доступ ограничен по роли — только `ORGANIZER` может создавать и редактировать квизы.

### Этап 4 — Реалтайм-движок на Socket.IO
Реализован отдельный Socket.IO-сервер с `sessionManager.ts` — in-memory хранилищем активных сессий. Разработаны обработчики событий жизненного цикла: подключение участников, старт вопроса с таймером, приём ответов, раскрытие правильных вариантов, расчёт и трансляция таблицы лидеров.

### Этап 5 — Пользовательский интерфейс
Разработаны страницы для обеих ролей:
- **Организатор**: редактор квизов, панель ведущего с управлением вопросами в реальном времени.
- **Участник**: страница ожидания в лобби, экран вопроса с таймером, экран результатов.

Реализованы кастомные хуки `useSocket` (управление подключением) и `useSession` (состояние игровой сессии).

### Этап 6 — Дизайн-система и UI-полировка
Разработана единая дизайн-система на базе Tailwind CSS с кастомными токенами: цветовая палитра (`#5E72A8`), система теней (`shadow-soft`, `shadow-hover`), радиусы скруглений, шрифт Outfit. Компоненты `Button`, `Card`, `Input`, `QuestionCard`, `Leaderboard`, `Timer` приведены к единому визуальному языку.

---

## 5. Возможности для масштабирования

| Направление | Решение |
|---|---|
| Деплой | Next.js → Vercel, Socket.IO → Railway/Fly.io, PostgreSQL → Supabase/Neon |
| Горизонтальное масштабирование WebSocket | Замена in-memory SessionManager на Redis Pub/Sub (Socket.IO Adapter) |
| Медиаконтент | Хранение изображений вопросов в S3-совместимом объектном хранилище |
| Мобильный клиент | REST API и Socket.IO-протокол совместимы с нативными iOS/Android клиентами |

---

*Стек: Next.js 14 · React 18 · TypeScript · Socket.IO · PostgreSQL · Prisma ORM · Tailwind CSS · Zod · bcryptjs*
